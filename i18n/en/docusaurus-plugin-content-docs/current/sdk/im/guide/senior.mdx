---
title: 3. Security, Permission Management, Chat Rooms, and Temporary Conversations
sidebar_label: Permission and Chat Rooms
sidebar_position: 3
---

import MultiLang from "/src/docComponents/MultiLang";
import Mermaid from "/src/docComponents/Mermaid";
import { Conditional } from "/src/docComponents/conditional";

## Introduction

In the previous chapter [Advanced Messaging Features, Push Notifications, Synchronization, and Multi-Device Sign-on](/sdk/im/guide/intermediate/), we introduced a number of bonus features that you can implement beyond basic messaging. In this chapter, we will introduce more features from the perspectives of system security and permission management, including:

- How to verify the requests made by clients with a third-party signing mechanism
- How to control the permissions each user has
- How to build a chat room with an unlimited number of people
- How to enforce text moderation on the messages sent by users
- How to implement temporary conversations

## Signing Mechanism

Instant Messaging is decoupled from the account system offered by Data Storage. This makes it possible for you to use Instant Messaging even though the account system of your app is not built with Data Storage. To ensure the security of your app, we offer a third-party signing mechanism that helps your app verify all the requests sent from clients.

The mechanism comes with an authentication server (the so-called "third party") deployed between clients and the cloud. Each time a client wants to make a request involving sensitive operations (like logging in, creating conversations, joining conversations, or inviting users), it has to obtain a signature from the authentication server. The signature gets attached to the request and will be verified by the cloud according to a predefined protocol. Only those requests with valid signatures will be accepted by the cloud.

The signing mechanism is turned off by default. You can turn it on by going to **Developer Center > Your game > Game Services > Cloud Services > Instant Messaging > Settings > Instant Messaging settings**:

- **Verify signatures for logging in**: Verify all the activities of logging in
- **Verify signatures for conversation operations**: Verify all the activities of creating conversations, joining conversations, inviting users, and removing users
- **Verify signatures for retrieving history messages**: Verify all the activities of retrieving history messages
- **Verify signatures for blacklist operations**: Verify all the activities of changing blacklisted users of conversations (see the next section for more details regarding blacklists)

You are free to change the settings here based on your app's actual needs, though we highly recommend that you at least keep **verifying signatures for logging in** on, which guarantees the basic security of your app.

<Mermaid
  diagram={`
sequenceDiagram
Client->>Authentication Server: 1. Apply for signature with request
Authentication Server-->>Client:  2. Return timestamp, nonce, and signature to the client
Client->>Authentication Server: 3. Send the request to the cloud with the signature
Authentication Server-->>Client: 4. Verify the signature along with the request
`}
/>

1. When the client performs operations like logging in or creating conversations, the SDK applies for a signature by calling `SignatureFactory` with the user's information and a request containing the operations to be done.
2. The authentication server checks if the operations are performed with enough permissions. If that's true, the server will follow the [signing algorithm](#signatures-for-logging-in) that will be mentioned later to generate the timestamp, nonce, and signature, and send them back to the client.
3. The client attaches the signature to the request and sends them to the cloud.
4. The cloud verifies the signature along with the request to ensure that the operations in the request are allowed. The request will be accepted only if the signature is valid.

The algorithm used for the signing process is **HMAC-SHA1** and the output would be the hex dump of a byte stream. For different requests, different strings with different UTC timestamps and nonces need to be constructed.

If you are using `LCUser` in your app, you can get signatures for logging in through our REST API.

### Formats of Signatures

Below we will introduce the formats of strings used to obtain signatures for different types of operations.

#### Signatures for Logging in

Below is the format of strings for logging in. Notice that there are _two colons_ between `clientid` and `timestamp`:

```
appid:clientid::timestamp:nonce
```

| Parameter   | Description                                                              |
| ----------- | ------------------------------------------------------------------------ |
| `appid`     | Your App ID.                                                             |
| `clientid`  | The `clientId` used for logging in.                                      |
| `timestamp` | The number of **milliseconds** that have elapsed since Unix epoch (UTC). |
| `nonce`     | A random string.                                                         |

> Note: The key for signing has to be the **Master Key** of your app. You can find it from **Developer Center > Your game > Game Services > Configuration**. **Make sure your Master Key is well-protected and doesn't get leaked.**

You may implement your own `SignatureFactory` to retrieve signatures from remote servers. If you don't have your own server, you may use the **web hosting** service provided by LeanEngine. Generating signatures within your mobile app is **extremely dangerous** since your **Master Key** can get exposed.

This signature expires in 6 hours, but it becomes invalid immediately once the client has been forced to log out.
The signature invalidness does not affect the currently connected clients.

#### Signatures for Creating Conversations

Below is the format of strings for creating conversations:

```
appid:clientid:sorted_member_ids:timestamp:nonce
```

- `appid`, `clientid`, `timestamp`, and `nonce` are [the same as above](#signatures-for-logging-in).
- `sorted_member_ids` is a list of `clientId`s (users being invited to the conversation) arranged in **ascending order** and divided by colon (`:`).

#### Signatures for Group Operations

Below is the format of strings for **joining conversations**, **inviting users**, and **removing users**:

```
appid:clientid:convid:sorted_member_ids:timestamp:nonce:action
```

- `appid`, `clientid`, `sorted_member_ids`, `timestamp`, and `nonce` are the same as above. `sorted_member_ids` would be an empty string if you are creating a new conversation.
- `convid` is the conversation ID.
- `action` is the operation being performed: `invite` means joining a conversation or inviting users and `kick` means removing users.

#### Signatures for Retrieving Message Histories

```
appid:client_id:convid:nonce:timestamp
```

The meanings of these parameters are the same as above.

This signature is only used for REST API. It is not applicable to client-side SDKs.

#### Signatures for Blacklist Operations

There are two formats of strings for two types of blacklist operations:

1. `client` to `conversation`

```
appid:clientid:convid::timestamp:nonce:action
```

- `action` is the operation being performed: `client-block-conversations` means blocking the conversation and `client-unblock-conversations` means unblocking the conversation.

2. `conversation` to `client`

```
appid:clientid:convid:sorted_member_ids:timestamp:nonce:action
```

- `action` is the operation being performed: `conversation-block-clients` means blocking the client and `conversation-unblock-clients` means unblocking the client.
- `sorted_member_ids` is the same as above.

### Demo for Generating Signatures on LeanEngine

To help you better understand the signing algorithm, we made a server-side signing program based on Node.js and LeanEngine. It's available [here](https://github.com/leancloud/leanengine-nodejs-demos/blob/master/functions/rtm-signature.js) for you to study and use.

### Supporting Signatures on the Client Side

So far we have been talking about the protocol used by the authentication server to generate signatures. Now let's see what we need to do with the client side to make the entire signing mechanism work.

The SDK reserves a factory interface `Signature` for each `AVIMClient` instance. To enable signing, implement the interface with a class that calls the signing method on the authentication server to get signatures, and then bind the class to the `AVIMClient` instance:

<MultiLang>

```cs
public class LocalSignatureFactory : ILCIMSignatureFactory {
    const string MasterKey = "pyvbNSh5jXsuFQ3C8EgnIdhw";

    public Task<LCIMSignature> CreateConnectSignature(string clientId) {
        long timestamp = DateTimeOffset.Now.ToUnixTimeSeconds();
        string nonce = NewNonce();
        string signature = GenerateSignature(LCApplication.AppId, clientId, string.Empty, timestamp.ToString(), nonce);
        return Task.FromResult(new LCIMSignature {
            Signature = signature,
            Timestamp = timestamp,
            Nonce = nonce
        });
    }

    public Task<LCIMSignature> CreateStartConversationSignature(string clientId, IEnumerable<string> memberIds) {
        string sortedMemberIds = string.Empty;
        if (memberIds != null) {
            List<string> sortedMemberList = memberIds.ToList();
            sortedMemberList.Sort();
            sortedMemberIds = string.Join(":", sortedMemberList);
        }
        long timestamp = DateTimeOffset.Now.ToUnixTimeSeconds();
        string nonce = NewNonce();
        string signature = GenerateSignature(LCApplication.AppId, clientId, sortedMemberIds, timestamp.ToString(), nonce);
        return Task.FromResult(new LCIMSignature {
            Signature = signature,
            Timestamp = timestamp,
            Nonce = nonce
        });
    }

    public Task<LCIMSignature> CreateConversationSignature(string conversationId, string clientId, IEnumerable<string> memberIds, string action) {
        string sortedMemberIds = string.Empty;
        if (memberIds != null) {
            List<string> sortedMemberList = memberIds.ToList();
            sortedMemberList.Sort();
            sortedMemberIds = string.Join(":", sortedMemberList);
        }
        long timestamp = DateTimeOffset.Now.ToUnixTimeSeconds();
        string nonce = NewNonce();
        string signature = GenerateSignature(LCApplication.AppId, clientId, conversationId, sortedMemberIds, timestamp.ToString(), nonce, action);
        return Task.FromResult(new LCIMSignature {
            Signature = signature,
            Timestamp = timestamp,
            Nonce = nonce
        });
    }

    public Task<LCIMSignature> CreateBlacklistSignature(string conversationId, string clientId, IEnumerable<string> memberIds, string action) {
        string sortedMemberIds = string.Empty;
        if (memberIds != null) {
            List<string> sortedMemberList = memberIds.ToList();
            sortedMemberList.Sort();
            sortedMemberIds = string.Join(":", sortedMemberList);
        }
        long timestamp = DateTimeOffset.Now.ToUnixTimeSeconds();
        string nonce = NewNonce();
        string signature = GenerateSignature(LCApplication.AppId, clientId, conversationId, sortedMemberIds, timestamp.ToString(), nonce, action);
        return Task.FromResult(new LCIMSignature {
            Signature = signature,
            Timestamp = timestamp,
            Nonce = nonce
        });
    }

    private static string SignSHA1(string key, string text) {
        HMACSHA1 hmac = new HMACSHA1(Encoding.UTF8.GetBytes(key));
        byte[] bytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(text));
        string signature = BitConverter.ToString(bytes).Replace("-", string.Empty);
        return signature;
    }

    private static string NewNonce() {
        byte[] bytes = new byte[10];
        using (RandomNumberGenerator generator = RandomNumberGenerator.Create()) {
            generator.GetBytes(bytes);
        }
        return Convert.ToBase64String(bytes);
    }

    private static string GenerateSignature(params string[] args) {
        string text = string.Join(":", args);
        string signature = SignSHA1(MasterKey, text);
        return signature;
    }
}

// Specify the signature factory
LCIMClient tom = new LCIMClient("tom", signatureFactory: new LocalSignatureFactory());
```

```java
// An example of performing signing with LeanEngine
public class KeepAliveSignatureFactory implements SignatureFactory {
 @Override
 public Signature createSignature(String peerId, List<String> watchIds) throws SignatureException {
   Map<String,Object> params = new HashMap<String,Object>();
   params.put("self_id",peerId);
   params.put("watch_ids",watchIds);

   try{
     Object result =  LCCloud.callFunction("sign",params);
     if(result instanceof Map){
       Map<String,Object> serverSignature = (Map<String,Object>) result;
       Signature signature = new Signature();
       signature.setSignature((String)serverSignature.get("signature"));
       signature.setTimestamp((Long)serverSignature.get("timestamp"));
       signature.setNonce((String)serverSignature.get("nonce"));
       return signature;
     }
   }catch(LCException e){
     throw (SignatureFactory.SignatureException) e;
   }
   return null;
 }

  @Override
  public Signature createConversationSignature(String convId, String peerId,
                                               List<String> targetPeerIds,String action) throws SignatureException{
   Map<String,Object> params = new HashMap<String,Object>();
   params.put("client_id",peerId);
   params.put("conv_id",convId);
   params.put("members",targetPeerIds);
   params.put("action",action);

   try{
     Object result = LCCloud.callFunction("sign2",params);
     if(result instanceof Map){
        Map<String,Object> serverSignature = (Map<String,Object>) result;
        Signature signature = new Signature();
        signature.setSignature((String)serverSignature.get("signature"));
        signature.setTimestamp((Long)serverSignature.get("timestamp"));
        signature.setNonce((String)serverSignature.get("nonce"));
        return signature;
     }
   }catch(LCException e){
     throw (SignatureFactory.SignatureException) e;
   }
   return null;
  }

  @Override
  public Signature createBlacklistSignature(String clientId, String conversationId, List<String> memberIds,
                                            String action) throws SignatureException {
    Map<String,Object> params = new HashMap<String,Object>();
    params.put("client_id",clientId);
    params.put("conv_id",conversationId);
    params.put("members",memberIds);
    params.put("action",action);

    try{
      Object result = LCCloud.callFunction("sign3",params);
      if(result instanceof Map){
         Map<String,Object> serverSignature = (Map<String,Object>) result;
         Signature signature = new Signature();
         signature.setSignature((String)serverSignature.get("signature"));
         signature.setTimestamp((Long)serverSignature.get("timestamp"));
         signature.setNonce((String)serverSignature.get("nonce"));
         return signature;
      }
    }catch(LCException e){
      throw (SignatureFactory.SignatureException) e;
    }
    return null;
  }
}

// Bind an instance of the signature factory class to LCIMClient
LCIMOptions.getGlobalOptions().setSignatureFactory(new KeepAliveSignatureFactory());
```

```objc
// Implement the LCIMSignatureDataSource protocol
- (void)client:(LCIMClient *)client
        action:(LCIMSignatureAction)action
  conversation:(LCIMConversation * _Nullable)conversation
     clientIds:(NSArray<NSString *> * _Nullable)clientIds
signatureHandler:(void (^)(LCIMSignature * _Nullable))handler
{
    if ([action isEqualToString:LCIMSignatureActionOpen]) {
        // For modules with signing enabled, return the corresponding signature
        LCIMSignature *signature;
        /*
         ...
         ...
         See "Demo for Generating Signatures on LeanEngine"
         */
        handler(signature);
    } else {
        // For modules with signing disabled, return nil
        handler(nil);
    }
}

// Set the protocol delegator
NSError *error;
LCIMClient *imClient = [[LCIMClient alloc] initWithClientId:@"Tom" error:&error];
if (!error) {
    imClient.signatureDataSource = signatureDelegator;
}
```

```js
// A LeanEngine-based signature factory for signing requests for logging in
var signatureFactory = function (clientId) {
  return AV.Cloud.rpc("sign", { clientId: clientId }); // AV.Cloud.rpc returns a Promise
};
// A LeanEngine-based signature factory for signing requests for creating conversations, joining conversations, inviting users, and removing users
var conversationSignatureFactory = function (
  conversationId,
  clientId,
  targetIds,
  action
) {
  return AV.Cloud.rpc("sign-conversation", {
    conversationId: conversationId,
    clientId: clientId,
    targetIds: targetIds,
    action: action,
  });
};
// A LeanEngine-based signature factory for signing requests for blacklist operations
var blacklistSignatureFactory = function (
  conversationId,
  clientId,
  targetIds,
  action
) {
  return AV.Cloud.rpc("sign-blacklist", {
    conversationId: conversationId,
    clientId: clientId,
    targetIds: targetIds,
    action: action,
  });
};

realtime
  .createIMClient("Tom", {
    signatureFactory: signatureFactory,
    conversationSignatureFactory: conversationSignatureFactory,
    blacklistSignatureFactory: blacklistSignatureFactory,
  })
  .then(function (tom) {
    console.log("Tom logged in.");
  })
  .catch(function (error) {
    // Errors thrown by signatureFactory or for invalid signatures will be caught here
  });
```

```swift
class SignatureDelegator: IMSignatureDelegate {

    // A LeanEngine-based function for getting signatures for logging in
    func getClientOpenSignature(completion: (IMSignature) -> Void) {
        // See "Demo for Generating Signatures on LeanEngine"
    }

    func client(_ client: IMClient, action: IMSignature.Action, signatureHandler: @escaping (IMClient, IMSignature?) -> Void) {
        switch action {
        case .open:
            // For modules with signing enabled, return the corresponding signature
            self.getClientOpenSignature { (signature) in
                signatureHandler(client, signature)
            }
        default:
            // For modules with signing disabled, return nil
            signatureHandler(client, nil)
        }
    }
}

do {
    let signatureDelegator = SignatureDelegator()
    let client = try IMClient(ID: "Tom", signatureDelegate: signatureDelegator)
} catch {
    print(error)
}
```

```dart
<!-- Todo -->
```

</MultiLang>

You should never perform signing using your Master Key on the client side. If your Master Key gets leaked, the data in your app would be accessible by anyone who has the key. Therefore, we highly recommend that you host the signing program on a server that is well-secured (like LeanEngine).

### Signing Mechanism for `User`

`User` is the built-in account system coming with Data Storage. If your users have their accounts signed up or logged in with `User`, they can skip the signing process when logging in to Instant Messaging. The code below shows how a user can log in to Instant Messaging with `User`:

<MultiLang>

```cs
LCUser user = await LCUser.Login("username", "password");
CIMClient client = new LCIMClient(user);
await client.Open();
```

```java
// Log in to the account system with the username and password of an LCUser
LCUser.logInInBackground("username", "password", new LogInCallback<LCUser>() {
    @Override
    public void done(LCUser user, LCException e) {
        if (null != e) {
          return;
        }
        // Create a client with the LCUser instance
        LCIMClient client = LCIMClient.getInstance(user);
        // Log in to Instant Messaging
        client.open(new LCIMClientCallback() {
          @Override
          public void done(final LCIMClient avimClient, LCIMException e) {
            // Do something as you need
          }
       });
    }
});
```

```objc
// Log in to the account system with the username and password of an LCUser
[LCUser logInWithUsernameInBackground:username password:password block:^(LCUser * _Nullable user, NSError * _Nullable error) {
    // Create a client with the LCUser instance
    NSError *err;
    LCIMClient *client = [[LCIMClient alloc] initWithUser:user error:&err];
    if (!err) {
        // Log in to Instant Messaging
        [client openWithCallback:^(BOOL succeeded, NSError * _Nullable error) {
            // Do something as you need
        }];
    }
}];
```

```js
var AV = require("leancloud-storage");
// Log in to the account system with the username and password of an LCUser
AV.User.logIn("username", "password")
  .then(function (user) {
    // Log in to Instant Messaging with the LCUser instance
    return realtime.createIMClient(user);
  })
  .catch(console.error.bind(console));
```

```swift
_ = LCUser.logIn(username: "username", password: "password") { (result) in
    switch result {
    case .success(object: let user):
        do {
            let client = try IMClient(user: user)
            client.open(completion: { (result) in
                // Do something as you need
            })
        } catch {
            print(error)
        }
    case .failure(error: let error):
        print(error)
    }
}
```

```dart
// Not supported yet
```

</MultiLang>

When creating `IMClient` with an `LCUser` instance that has completed the `logIn` process, the user's signature information can be directly accessed by Instant Messaging from the account system. This allows Instant Messaging to automatically verify the client being logged in and the process of applying for signatures from the third-party server can be skipped.

Once `IMClient` is logged in, all the other features work in the same way as discussed earlier.

## Permission Management and Blacklisting

The third-party signing mechanism helps to maintain the general security of your app, but each conversation still needs to keep its own order. For example, a chat room may need managers that can temporarily or permanently mute users that are behaving improperly. In this section, we will talk about how permission management within conversations can be implemented.

### Setting Member Permissions

When permission management is enabled, members in each conversation will be divided into different roles with different permissions. To enable permission management, go to **Developer Center > Your game > Game Services > Cloud Services > Instant Messaging > Settings > Instant Messaging settings** and turn on **Enable permission management for conversations**.

Here is a table showing the permissions each role has:

| Role      | Permissions                                                                                            |
| --------- | ------------------------------------------------------------------------------------------------------ |
| `Owner`   | Mute members, remove members, invite members, blacklist members, and update other members' permissions |
| `Manager` | Mute members, remove members, invite members, blacklist members, and update other members' permissions |
| `Member`  | Join conversations                                                                                     |

Among all these roles, `Owner` has the highest permissions and `Member` has the lowest. A member with higher permissions can change the role of a member with lower permissions, but not vice versa. In the previous chapters, we have seen that all the members in a conversation can invite or remove people, but once permission management is enabled, only `Owner` and `Manager` can perform these operations. Other members will get an error when attempting to do so.

The `Owner` of a conversation cannot be changed. For other members, their roles can be switched between `Manager` and `Member` with `Conversation#updateMemberRole`:

<MultiLang>

```cs
/// <summary>
/// Updates the role of a member of this conversation.
/// </summary>
/// <param name="memberId">The member to update.</param>
/// <param name="role">The new role of the member.</param>
/// <returns></returns>
public async Task UpdateMemberRole(string memberId, string role);
```

```java
/**
 * Update the role of a member
 * @param memberId  The member's clientId
 * @param role      The role
 * @param callback  Callback function
 */
public void updateMemberRole(final String memberId, final ConversationMemberRole role, final LCIMConversationCallback callback);
```

```objc
/**
 Update the role of a member

 @param memberId The member's clientId
 @param role The role
 @param callback Callback function
 */
- (void)updateMemberRoleWithMemberId:(NSString *)memberId
                                role:(LCIMConversationMemberRole)role
                            callback:(void (^)(BOOL succeeded, NSError * _Nullable error))callback;
```

```js
/**
 * Update the role of a member
 * @since 4.0.0
 * @param {String} memberId The member's clientId
 * @param {module:leancloud-realtime.ConversationMemberRole | String} role The role
 * @return {Promise.<this>} self
 */
async updateMemberRole(memberId, role);
```

```swift
/// Updating role of the member in the conversation.
///
/// - Parameters:
///   - role: The role will be updated.
///   - memberID: The ID of the member who will be updated.
///   - completion: Result of callback.
/// - Throws: If role parameter is owner, throw error.
public func update(role: MemberRole, ofMember memberID: String, completion: @escaping (LCBooleanResult) -> Void) throws
```

```dart
/// - role: The role will be updated.
/// - memberId: The ID of the member who will be updated.
Future<void> updateMemberRole({String role, String memberId})
```

</MultiLang>

### Getting Member Permissions

A `Conversation` object offers two ways for getting permission information of members:

- `Conversation#getAllMemberInfo()` can be used to get all members' permission information

  <MultiLang>

  ```cs
  /// <summary>
  /// Gets all member roles.
  /// </summary>
  /// <returns></returns>
  public async Task<ReadOnlyCollection<LCIMConversationMemberInfo>> GetAllMemberInfo();
  ```

  ```java
  /**
  * Get all members' permission information
  * @param offset    The number of results skipped
  * @param limit     The maximum number of results
  * @param callback  Callback function
  */
  public void getAllMemberInfo(int offset, int limit, final LCIMConversationMemberQueryCallback callback);
  ```

  ```objc
  /**
  Get all members' permission information; cache is used by default

  @param callback Callback function
  */
  - (void)getAllMemberInfoWithCallback:(void (^)(NSArray<LCIMConversationMemberInfo *> * _Nullable memberInfos, NSError * _Nullable error))callback;

  /**
  Get all members' permission information

  @param ignoringCache Whether to use cache
  @param callback Callback function
  */
  - (void)getAllMemberInfoWithIgnoringCache:(BOOL)ignoringCache
                                  callback:(void (^)(NSArray<LCIMConversationMemberInfo *> * _Nullable memberInfos, NSError * _Nullable error))callback;
  ```

  ```js
  /**
   * Get all members' permission information
   * @since 4.0.0
   * @return {Promise.<ConversationMemberInfo[]>} A list containing all members' permission information
   */
  async getAllMemberInfo({ noCache = false } = {})
  ```

  ```swift
  /// Fetching the table of member information in the conversation.
  /// The result will be cached by the property `memberInfoTable`.
  ///
  /// - Parameter completion: Result of callback.
  public func fetchMemberInfoTable(completion: @escaping (LCBooleanResult) -> Void)

  /// The table of member information.
  public var memberInfoTable: [String : MemberInfo]? { get }
  ```

  ```dart
  // Not supported yet
  ```

  </MultiLang>

- `Conversation#getMemberInfo(memberId)` can be used to get a specific member's permission information

  <MultiLang>

  ```cs
  /// <summary>
  /// Gets the role of a specific member.
  /// </summary>
  /// <param name="memberId">The member to query.</param>
  /// <returns></returns>
  public async Task<LCIMConversationMemberInfo> GetMemberInfo(string memberId);
  ```

  ```java
  /**
  * Get a specific member's permission information
  * @param memberId  The member's clientId
  * @param callback  Callback function
  */
  public void getMemberInfo(final String memberId, final LCIMConversationMemberQueryCallback callback);
  ```

  ```objc
  /**
  Get a specific member's permission information; cache is used by default

  @param memberId The member's clientId
  @param callback Callback function
  */
  - (void)getMemberInfoWithMemberId:(NSString *)memberId
                          callback:(void (^)(LCIMConversationMemberInfo * _Nullable memberInfo, NSError * _Nullable error))callback;
  ```

  ```js
  /**
   * Get a specific member's permission information
   * @since 4.0.0
   * @param {String} memberId The member's clientId
   * @return {Promise.<ConversationMemberInfo>} The member's permission information
   */
  async getMemberInfo(memberId);
  ```

  ```swift
  /// Get information of one member in the conversation.
  ///
  /// - Parameters:
  ///   - memberID: The ID of the member.
  ///   - completion: Result of callback.
  public func getMemberInfo(by memberID: String, completion: @escaping (LCGenericResult<MemberInfo?>) -> Void)
  ```

  ```dart
  // Not supported yet
  ```

  </MultiLang>

Each return value contains permission information of members in a triple or array `<ConversationId, MemberId, ConversationMemberRole>`.

### Muting Members

Members whose roles are `Owner` or `Manager` can mute other members so they can only receive messages from the conversation. They will get an error when they attempt to send a message.

`LCIMConversation` offers the following methods related to muting members:

<MultiLang>

```cs
/// <summary>
/// Mutes members of this conversation.
/// </summary>
/// <param name="clientIds">Member list.</param>
/// <returns></returns>
public async Task<LCIMPartiallySuccessResult> MuteMembers(IEnumerable<string> clientIds);
/// <summary>
/// Unmutes members of this conversation.
/// </summary>
/// <param name="clientIdList">Member list.</param>
/// <returns></returns>
public async Task<LCIMPartiallySuccessResult> UnmuteMembers(IEnumerable<string> clientIds);
/// <summary>
/// Queries muted members.
/// </summary>
/// <param name="limit">Limits the number of returned results.</param>
/// <param name="next">Can be used for pagination with the limit parameter.</param>
/// <returns></returns>
public async Task<LCIMPageResult> QueryMutedMembers(int limit = 10, string next = null);
```

```java
/**
 * Mute certain members in the current conversation
 * @param memberIds  The members' clientIds
 * @param callback   Callback function
 */
public void muteMembers(final List<String> memberIds, final LCIMOperationPartiallySucceededCallback callback);
/**
 * Unmute certain members in the current conversation
 * @param memberIds  The members' clientIds
 * @param callback   Callback function
 */
public void unmuteMembers(final List<String> memberIds, final LCIMOperationPartiallySucceededCallback callback);
/**
 * Get a list of members being muted in the current conversation
 * @param offset    The number of results skipped
 * @param limit     The maximum number of results
 * @param callback  Callback function
 */
public void queryMutedMembers(int offset, int limit, final LCIMConversationSimpleResultCallback callback);
```

```objc
/**
 Mute certain members in the current conversation

 @param memberIds The members' clientIds
 @param callback Callback function
 */
- (void)muteMembers:(NSArray<NSString *> *)memberIds
           callback:(void (^)(NSArray<NSString *> * _Nullable successfulIds, NSArray<LCIMOperationFailure *> * _Nullable failedIds, NSError * _Nullable error))callback;
/**
 Unmute certain members in the current conversation

 @param memberIds The members' clientIds
 @param callback Callback function
 */
- (void)unmuteMembers:(NSArray<NSString *> *)memberIds
             callback:(void (^)(NSArray<NSString *> * _Nullable successfulIds, NSArray<LCIMOperationFailure *> * _Nullable failedIds, NSError * _Nullable error))callback;
/**
 Get a list of members being muted in the current conversation

 @param limit The maximum number of results
 @param next The number of results skipped; next becomes nil or empty if there are no more muted members
 @param callback Callback function
 */
- (void)queryMutedMembersWithLimit:(NSInteger)limit
                              next:(NSString * _Nullable)next
                          callback:(void (^)(NSArray<NSString *> * _Nullable mutedMemberIds, NSString * _Nullable next, NSError * _Nullable error))callback;
```

```js
/**
 * Mute certain members in the current conversation
 * @param {String|String[]} clientIds The members' clientIds
 * @return {Promise.<PartiallySuccess>} Result of the operation, including the clientIds that are operated successfully, plus the failures occurred and the clientIds associated with each of them
 */
async muteMembers(clientIds);

/**
 * Unmute certain members in the current conversation
 * @param {String|String[]} clientIds The members' clientIds
 * @return {Promise.<PartiallySuccess>} Result of the operation, including the clientIds that are operated successfully, plus the failures occurred and the clientIds associated with each of them
 */
async unmuteMembers(clientIds);

/**
 * Get a list of members being muted in the current conversation
 * @param {Object} [options]
 * @param {Number} [options.limit] The maximum number of results; defaults to 10
 * @param {String} [options.next] The number of results skipped; can be used with limit for pagination
 * @return {PagedResults.<string>} Results; the existence of cureser indicates that there are more results
 */
async queryMutedMembers({ limit, next } = {});
```

```swift
/// Muting members in the conversation.
///
/// - Parameters:
///   - members: The members will be muted.
///   - completion: Result of callback.
/// - Throws: When parameter `members` is empty.
public func mute(members: Set<String>, completion: @escaping (MemberResult) -> Void) throws

/// Unmuting members in the conversation.
///
/// - Parameters:
///   - members: The members will be unmuted.
///   - completion: Result of callback.
/// - Throws: When parameter `members` is empty.
public func unmute(members: Set<String>, completion: @escaping (MemberResult) -> Void) throws

/// Get the muted members in the conversation.
///
/// - Parameters:
///   - limit: Count limit.
///   - next: Offset.
///   - completion: Result of callback.
/// - Throws: When parameter `limit` out of range.
public func getMutedMembers(limit: Int = 50, next: String? = nil, completion: @escaping (LCGenericResult<MutedMembersResult>) -> Void) throws

/// Check if one member has been muted in the conversation.
///
/// - Parameters:
///   - ID: The ID of member.
///   - completion: Result of callback.
public func checkMuting(member ID: String, completion: @escaping (LCGenericResult<Bool>) -> Void)
```

```dart
/// - members: The members will be muted.
Future<MemberResult> muteMembers({Set<String> members})

/// - members: The members will be unmuted.
Future<MemberResult> unmuteMembers({Set<String> members})

/// Get the muted members in the conversation.
///
/// [limit]'s default is `50`, should not more than `100`.
/// [next]'s default is `null`.
///
/// Returns a list of members.
Future<QueryMemberResult> queryMutedMembers({int limit = 50, String next})
```

</MultiLang>

Note that the result of the operation contains three parts of data:

- `error`/`exception`: Whether the operation is holistically successful. If false, you will get error messages from here and the following two parts can be ignored.
- `successfulClientIds`: The clientIds that are operated successfully.
- `failedIds`: The failures occurred and the clientIds associated with each of them; listed in the format of `List<ReasonString, List<ClientId>>`.

#### Events for Muting Members

All the members in the conversation will receive notifications when someone gets muted.

### Blacklisting

There are two types of blacklists available:

- Conversation to user: The list of users that are blocked by a conversation. Blocked users cannot join the conversation.
- User to conversation: The list of conversations that are blocked by a user. The user cannot be invited to a blocked conversation.

To enable blacklists, go to **Developer Center > Your game > Game Services > Cloud Services > Instant Messaging > Settings > Instant Messaging settings** and turn on **Enable blacklists**.

The `LCIMConversation` class offers the following methods related to blacklisting:

<MultiLang>

```cs
/// <summary>
/// Adds members to the blocklist of this conversation.
/// </summary>
/// <param name="clientIds">Member list.</param>
/// <returns></returns>
public async Task<LCIMPartiallySuccessResult> BlockMembers(IEnumerable<string> clientIds);
/// <summary>
/// Removes members from the blocklist of this conversation.
/// </summary>
/// <param name="clientIds">Member list.</param>
/// <returns></returns>
public async Task<LCIMPartiallySuccessResult> UnblockMembers(IEnumerable<string> clientIds);
/// <summary>
/// Queries blocked members.
/// </summary>
/// <param name="limit">Limits the number of returned results.</param>
/// <param name="next">Can be used for pagination with the limit parameter.</param>
/// <returns></returns>
public async Task<LCIMPageResult> QueryBlockedMembers(int limit = 10, string next = null);
```

```java
/**
 * Put certain users into the blacklist of the current conversation
 * @param memberIds  The users' clientIds
 * @param callback   Callback function
 */
public void blockMembers(final List<String> memberIds, final LCIMOperationPartiallySucceededCallback callback);
/**
 * Remove certain users from the blacklist of the current conversation
 * @param memberIds  The users' clientIds
 * @param callback   Callback function
 */
public void unblockMembers(final List<String> memberIds, final LCIMOperationPartiallySucceededCallback callback);
/**
 * Get the blacklist of the current conversation
 * @param offset    The number of results skipped
 * @param limit     The maximum number of results
 * @param callback  Callback function
 */
public void queryBlockedMembers(int offset, int limit, final LCIMConversationSimpleResultCallback callback);
```

```objc
/**
 Put certain users into the blacklist of the current conversation

 @param memberIds The users' clientIds
 @param callback Callback function
 */
- (void)blockMembers:(NSArray<NSString *> *)memberIds
            callback:(void (^)(NSArray<NSString *> * _Nullable successfulIds, NSArray<LCIMOperationFailure *> * _Nullable failedIds, NSError * _Nullable error))callback;

/**
 Remove certain users from the blacklist of the current conversation

 @param memberIds The users' clientIds
 @param callback Callback function
 */
- (void)unblockMembers:(NSArray<NSString *> *)memberIds
              callback:(void (^)(NSArray<NSString *> * _Nullable successfulIds, NSArray<LCIMOperationFailure *> * _Nullable failedIds, NSError * _Nullable error))callback;

/**
 Get the blacklist of the current conversation

 @param limit The maximum number of results
 @param next The number of results skipped; next becomes nil or empty if there are no more muted members
 @param callback Callback function
 */
- (void)queryBlockedMembersWithLimit:(NSInteger)limit
                                next:(NSString * _Nullable)next
                            callback:(void (^)(NSArray<NSString *> * _Nullable blockedMemberIds, NSString * _Nullable next, NSError * _Nullable error))callback;
```

```js
/**
 * Put certain users into the blacklist of the current conversation
 * @param {String|String[]} clientIds The users' clientIds
 * @return {Promise.<PartiallySuccess>} Result of the operation, including the clientIds that are operated successfully, plus the failures occurred and the clientIds associated with each of them
 */
async blockMembers(clientIds);

/**
 * Remove certain users from the blacklist of the current conversation
 * @param {String|String[]} clientIds The users' clientIds
 * @return {Promise.<PartiallySuccess>} Result of the operation, including the clientIds that are operated successfully, plus the failures occurred and the clientIds associated with each of them
 */
async unblockMembers(clientIds);

/**
 * Get the blacklist of the current conversation
 * @param {Object} [options]
 * @param {Number} [options.limit] The maximum number of results; defaults to 10
 * @param {String} [options.next] The number of results skipped; can be used with limit for pagination
 * @return {PagedResults.<string>} Results; the existence of cureser indicates that there are more results
 */
async queryBlockedMembers({ limit, next } = {});
```

```swift
/// Blocking members in the conversation.
///
/// - Parameters:
///   - members: The members will be blocked.
///   - completion: Result of callback.
/// - Throws: When parameter `members` is empty.
public func block(members: Set<String>, completion: @escaping (MemberResult) -> Void) throws

/// Unblocking members in the conversation.
///
/// - Parameters:
///   - members: The members will be unblocked.
///   - completion: Result of callback.
/// - Throws: When parameter `members` is empty.
public func unblock(members: Set<String>, completion: @escaping (MemberResult) -> Void) throws

/// Get the blocked members in the conversation.
///
/// - Parameters:
///   - limit: Count limit.
///   - next: Offset.
///   - completion: Result of callback.
/// - Throws: When limit out of range.
public func getBlockedMembers(limit: Int = 50, next: String? = nil, completion: @escaping (LCGenericResult<BlockedMembersResult>) -> Void) throws

/// Check if one member has been blocked in the conversation.
///
/// - Parameters:
///   - ID: The ID of member.
///   - completion: Result of callback.
public func checkBlocking(member ID: String, completion: @escaping (LCGenericResult<Bool>) -> Void)
```

```dart
/// - members: The members will be blocked.
Future<MemberResult> blockMembers({Set<String> members})

/// - members: The members will be un unblocked.
Future<MemberResult> unblockMembers({Set<String> members})

/// Get the blocked members in the conversation.
///
/// [limit]'s default is `50`, should not more than `100`.
/// [next]'s default is `null`.
///
/// Returns a list of members.
Future<QueryMemberResult> queryBlockedMembers({int limit = 50, String next})
```

</MultiLang>

> The result of the operation is similar to that for muting members. You get the clientIds that are operated successfully, plus the failures occurred and the clientIds associated with each of them.

Once a user is added to the blacklist of a conversation, the user will be removed from the conversation and cannot receive messages from it anymore. Unless the user is removed from the blacklist, other members will not be able to add this user back to the conversation.

#### Events for Blacklisting

All the members in the conversation will receive notifications when someone gets blacklisted.

#### Blocking Messages from Specific Users

Another scenario is that a user doesn't want to receive messages from a specific user. This can be implemented with hooks. See [Hooks](/sdk/im/guide/systemconv/) for more details.

## Chat Rooms

We have compared different types of scenarios and conversations in our service overview. Now let's learn how to build a chat room.

### Creating Chat Rooms

`IMClient` has the `createChatRoom` method for creating chat rooms:

<MultiLang>

```cs
// Pass in the name of the chat room
tom.CreateChatRoom("Chat Room");
```

```java
tom.createChatRoom("Chat Room", null,
    new LCIMConversationCreatedCallback() {
        @Override
        public void done(LCIMConversation conv, LCIMException e) {
            if (e == null) {
                // Chat room created
            }
        }
});
```

```objc
[client createChatRoomWithCallback:^(LCIMChatRoom * _Nullable chatRoom, NSError * _Nullable error) {
    if (chatRoom && !error) {
        LCIMTextMessage *textMessage = [LCIMTextMessage messageWithText:@"This is a message." attributes:nil];
        [chatRoom sendMessage:textMessage callback:^(BOOL success, NSError *error) {
            if (success && !error) {

            }
        }];
    }
}];
```

```js
tom.createChatRoom({ name: "Chat Room" }).catch(console.error);
```

```swift
do {
    try client.createChatRoom(name: "Chat Room", attributes: nil) { (result) in
        switch result {
        case .success(value: let chatRoom):
            print(chatRoom)
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```

```dart
ChatRoom chatRoom = await jerry.createChatRoom(name: 'Chat Room');
```

</MultiLang>

When creating a chat room, you can specify its name and optional attributes. The interface for creating chat rooms has the following differences compared to that for creating basic conversations:

- A chat room doesn't have a member list, so there is no need to specify `members`.
- For the same reason, there is no need to specify `unique` (the cloud doesn't need to merge conversations by member lists).

> Although it's possible to create a chat room by passing `{ transient: true }` into `createConversation`, we still recommend that you use `createChatRoom` directly.

### Finding Chat Rooms

In the first chapter, we have discussed how you can use `ConversationsQuery` to look for conversations with your custom conditions. This works for chat rooms as well, as long as you add `transient = true` as a constraint.

<MultiLang>

```cs
LCIMConversationQuery query = new LCIMConversationQuery(tom);
query.WhereEqualTo("tr", true);
```

```java
LCIMConversationsQuery query = tom.getChatRoomQuery();
query.findInBackground(new LCIMConversationQueryCallback() {
    @Override
    public void done(List<LCIMConversation> conversations, LCIMException e) {
        if (null == e) {
            // Success
        } else {
            // Error handling
        }
    }
});
```

```objc
LCIMConversationQuery *query = [tom conversationQuery];
[query whereKey:@"tr" equalTo:@(YES)];
```

```js
var query = tom.getQuery().equalTo("tr", true); // Restrict to chat rooms
query
  .find()
  .then(function (conversations) {
    // conversations contains all the results
  })
  .catch(console.error);
```

```swift
do {
    let query = client.conversationQuery
    try query.where("tr", .equalTo(true))
    try query.findConversations { (result) in
        switch result {
        case .success(value: let conversations):
            guard conversations is [IMChatRoom] else {
                return
            }
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```

```dart
try {
  ConversationQuery query = tom.conversationQuery();
  query.whereEqualTo('tr', true);
  // conversations contains all the results
  List<Conversation> conversations = await query.find();
} catch (e) {
  print(e);
}
```

</MultiLang>

> Java, Android, and C# SDKs offer their `LCIMClient#getChatRoomQuery` methods that are dedicated to querying chat rooms. By using them, you won't need to deal with the `transient` attribute of conversations.

### Joining and Leaving Chat Rooms

When coming to the interfaces for joining or leaving conversations, group chats are the same as basic conversations. See [Group Chats](/sdk/im/guide/beginner/) in the first chapter for more details.

However, there are several differences in the ways members are managed and notifications are delivered:

- A user cannot be invited to or removed from a chat room. They are only able to join or leave on their own.
- If a user logs out, this user will be automatically removed from the chat room they are already in. An exception is that if the user gets offline unexpectedly, they will be added back to the chat room they are previously in as long as they get back within 30 minutes.
- The cloud will not deliver notifications for users joining or leaving chat rooms.
- The list of members in a chat room cannot be retrieved. Only the count of members is available.

As a side note, functions like **push notifications, message synchronization, and receipts are also not supported by chat rooms**.

### Getting Member Counts

The `LCIMConversation#memberCount` method lets you get the count of members in a conversation. When used on a chat room, you get the number of people in it at that moment:

<MultiLang>

```cs
int membersCount = await conversation.GetMembersCount();
```

```java
private void TomQueryWithLimit() {
  LCIMClient tom = LCIMClient.getInstance("Tom");
  tom.open(new LCIMClientCallback() {

    @Override
    public void done(LCIMClient client, LCIMException e) {
      if (e == null) {
        // Successfully logged in
        LCIMConversationsQuery query = tom.getConversationsQuery();
        query.setLimit(1);
        // Get the first conversation
        query.findInBackground(new LCIMConversationQueryCallback() {
          @Override
          public void done(List<LCIMConversation> convs, LCIMException e) {
            if (e == null) {
              if (convs != null && !convs.isEmpty()) {
                LCIMConversation conv = convs.get(0);
                // Get the count of people in the first conversation
                conv.getMemberCount(new LCIMConversationMemberCountCallback() {

                  @Override
                  public void done(Integer count, LCIMException e) {
                    if (e == null) {
                      Log.d("Tom & Jerry has " + count + " people online");
                    }
                  }
                });
              }
            }
          }
        });
      }
    }
  });
}
```

```objc
// Get the count of people
[conversation countMembersWithCallback:^(NSInteger number, NSError *error) {
    NSLog(@"%ld",number);
}];
```

```js
chatRoom
  .count()
  .then(function (count) {
    console.log("Count: " + count);
  })
  .catch(console.error.bind(console));
```

```swift
do {
    chatRoom.getOnlineMembersCount { (result) in
        switch result {
        case .success(count: let count):
            print(count)
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```

```dart
int count = await chatRoom.countMembers();
```

</MultiLang>

### Message Priorities

To ensure that important messages get delivered promptly, the server would selectively discard a certain amount of messages with lower priorities when the network connection is bad. Below are the priorities supported:

| Priority                 | Description                                                          |
| ------------------------ | -------------------------------------------------------------------- |
| `MessagePriority.HIGH`   | High priority. Used for messages that need to be delivered promptly. |
| `MessagePriority.NORMAL` | Normal priority. Used for ordinary text messages.                    |
| `MessagePriority.LOW`    | Low priority. Used for messages that are less important.             |

The default priority is `NORMAL`.

The priority of a message can be set when sending the message. The code below shows how you can send a message with high priority:

<MultiLang>

```cs
LCIMTextMessage message = new LCIMTextMessage("The score is still 0:0. China definitely needs a substitution for the second half.");
LCIMMessageSendOptions options = new LCIMMessageSendOptions {
    Priority = LCIMMessagePriority.High
};
await chatRoom.Send(message, options);
```

```java
LCIMClient tom = LCIMClient.getInstance("Tom");
    tom.open(new LCIMClientCallback() {
      @Override
      public void done(LCIMClient client, LCIMException e) {
        if (e == null) {
          // Create a conversation named "Tom & Jerry"
          client.createConversation(Arrays.asList("Jerry"), "Tom & Jerry", null,
            new LCIMConversationCreatedCallback() {
              @Override
              public void done(LCIMConversation conv, LCIMException e) {
                if (e == null) {
                  LCIMTextMessage msg = new LCIMTextMessage();
                  msg.setText("Get up, Jerry!");

                  LCIMMessageOption messageOption = new LCIMMessageOption();
                  messageOption.setPriority(LCIMMessageOption.MessagePriority.High);
                  conv.sendMessage(msg, messageOption, new LCIMConversationCallback() {
                    @Override
                    public void done(LCIMException e) {
                      if (e == null) {
                        // Sent
                      }
                    }
                  });
                }
              }
            });
        }
      }
    });
```

```objc
LCIMMessageOption *option = [[LCIMMessageOption alloc] init];
option.priority = LCIMMessagePriorityHigh;
[chatRoom sendMessage:[LCIMTextMessage messageWithText:@"Get up, Jerry!" attributes:nil] option:option callback:^(BOOL succeeded, NSError * _Nullable error) {
    // Things to do after the message is sent
}];
```

```js
var { Realtime, TextMessage, MessagePriority } = require("leancloud-realtime");
var realtime = new Realtime({
  appId: "GDBz24d615WLO5e3OM3QFOaV-gzGzoHsz",
  appKey: "dlCDCOvzMnkXdh2czvlbu3Pk",
});
realtime
  .createIMClient("host")
  .then(function (host) {
    return host.createConversation({
      members: ["broadcast"],
      name: "2094 FIFA World Cup - Vatican City vs China",
      transient: true,
    });
  })
  .then(function (conversation) {
    console.log(conversation.id);
    return conversation.send(
      new TextMessage(
        "The score is still 0:0. China definitely needs a substitution for the second half."
      ),
      { priority: MessagePriority.HIGH }
    );
  })
  .then(function (message) {
    console.log(message);
  })
  .catch(console.error);
```

```swift
do {
    let message = IMTextMessage(text: "The score is still 0:0. China definitely needs a substitution for the second half.")
    try chatRoom.send(message: message, priority: .high) { (result) in
        switch result {
        case .success:
            break
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```

```dart
try {
  TextMessage message = TextMessage();
  message.text = 'The score is still 0:0. China definitely needs a substitution for the second half.';
  await chatRoom.send(message: message, priority: MessagePriority.high);
} catch (e) {
  print(e);
}
```

</MultiLang>

> Note:
>
> This feature is only available for _chat rooms_. There won't be an effect if you set priorities for messages in basic conversations, since these messages will never get discarded.

### Muting Conversations

If a user doesn't want to get notifications for new messages in a conversation but still wants to stay in the conversation, they can mute the conversation.

For example, Tom is getting busy and wants to mute a conversation:

<MultiLang>

```cs
await chatRoom.Mute();
```

```java
LCIMClient tom = LCIMClient.getInstance("Tom");
tom.open(new LCIMClientCallback(){

    @Override
    public void done(LCIMClient client,LCIMException e){
      if(e==null){
      // Logged in
      LCIMConversation conv = client.getConversation("551260efe4b01608686c3e0f");
      conv.mute(new LCIMConversationCallback(){

        @Override
        public void done(LCIMException e){
          if(e==null){
          // Muted
          }
        }
      });
      }
    }
});
```

```objc
// Tom mutes the conversation
[conversation muteWithCallback:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        NSLog(@"Muted!");
    }
}];
```

```js
tom
  .getConversation("CONVERSATION_ID")
  .then(function (conversation) {
    return conversation.mute();
  })
  .then(function (conversation) {
    console.log("Muted!");
  })
  .catch(console.error.bind(console));
```

```swift
conversation.mute { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```

```dart
await chatRoom.mute();
```

</MultiLang>

After a conversation is muted, the current user will not get push notifications from it anymore. To unmute a conversation, use `Conversation#unmute`.

> Tips:
>
> - Both chat rooms and basic conversations can be muted.
> - `mute` and `unmute` operations will change the `mu` field in the `_Conversation` class. **Do not change the `mu` field directly in your app's dashboard**, otherwise push notifications may not work properly.

### Text Moderation

<Conditional region="cn">

You might consider filtering cuss words out from the messages sent into group chats by users. Instant Messaging offers a built-in text moderation function that supports this need. It works for group chats, chat rooms, and system conversations by default. You can also enable it for one-on-one chats by going to **Developer Center > Your game > Game Services > Cloud Services > Instant Messaging > Settings**.

</Conditional>

<Conditional region="global">

Instant Messaging offers a built-in text moderation function that allows you to filter cuss words out from the messages sent by users. You can enable it for one-on-one chats by going to **Developer Center > Your game > Game Services > Cloud Services > Instant Messaging > Settings**.

</Conditional>

Matched keywords will be replaced with `***`.

Text moderation will lead to message modifications at the system level, so the message sender will receive a `MESSAGE_UPDATE` event, which the clients can listen to. Please refer to the "Modify a Message" section of the previous chapter for code samples.

<Conditional region="cn">

Instant Messaging offers a set of keywords by default, but if you have upgraded to the Business Plan, you can customize the keywords. To do so, go to **Developer Center > Your game > Game Services > Cloud Services > Instant Messaging > Settings** and upload your keywords file to replace the default list. The uploaded file must be UTF-8 encoded with one keyword in each line. If you upload your custom word list, it will override the default one.

</Conditional>

<Conditional region="global">

If you have upgraded to the Business Plan, you can customize the keywords. To do so, go to **Developer Center > Your game > Game Services > Cloud Services > Instant Messaging > Settings** and upload your keywords file. The uploaded file must be UTF-8 encoded with one keyword in each line. For now, the **Enable sensitive keyword filtering against group chats** option on **Developer Center > Your game > Game Services > Cloud Services > Instant Messaging > Settings** is always enabled, but if you don't upload a file of keywords, the text moderation function will not function in the end.

</Conditional>

If you have more complicated requirements regarding text moderation, we recommend that you make use of the `_messageReceived` hook of LeanEngine. You can define your own logic for controlling messages.

## Temporary Conversations

Temporary conversations can be used for special scenarios with:

- Short TTL
- Fewer members (10 `clientId`s maximum)
- No message history needed

What makes temporary conversations different from other conversations is that they **expire very quickly**. This helps you reduce the space needed for storing conversations and lower the cost of maintaining your app. Temporary conversations are best used for customer service systems.

### Creating Temporary Conversations

`IMConversation` has its `createTemporaryConversation` method for creating temporary conversations:

<MultiLang>

```cs
LCIMTemporaryConversation temporaryConversation = await tom.CreateTemporaryConversation(new string[] { "Jerry", "William" });
```

```java
tom.createTemporaryConversation(Arrays.asList(members), 3600, new LCIMConversationCreatedCallback(){
    @Override
    public void done(LCIMConversation conversation, LCIMException e) {
        if (null == e) {
        LCIMTextMessage msg = new LCIMTextMessage();
        msg.setText("This is a temporary conversation.");
        conversation.sendMessage(msg, new LCIMConversationCallback(){
            @Override
            public void done(LCIMException e) {
            }
        });
        }
    }
});
```

```objc
[self createTemporaryConversationWithClientIds:@[@"Jerry", @"William"] callback:^(LCIMTemporaryConversation * _Nullable temporaryConversation, NSError * _Nullable error) {
    if (temporaryConversation) {
        // success
    }
}];
```

```js
realtime
  .createIMClient("Tom")
  .then(function (tom) {
    return tom.createTemporaryConversation({
      members: ["Jerry", "William"],
    });
  })
  .then(function (conversation) {
    return conversation.send(
      new AV.TextMessage("This is a temporary conversation.")
    );
  })
  .catch(console.error);
```

```swift
do {
    try client.createTemporaryConversation(clientIDs: ["Jerry", "William"], timeToLive: 3600) { (result) in
        switch result {
        case .success(value: let tempConversation):
            print(tempConversation)
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```

```dart
TemporaryConversation temporaryConversation;
try {
  temporaryConversation = await jerry.createTemporaryConversation(
    members: {'Jerry', 'William'},
  );
} catch (e) {
  print(e);
}

try {
  TextMessage message = TextMessage();
  message.text = 'This is a temporary conversation.';
  await temporaryConversation.send(message: message);
} catch (e) {
  print(e);
}
```

</MultiLang>

Temporary conversations have an **important** attribute that differentiates them from others: TTL. It is set to 1 day by default, but you can change it to any time no longer than 30 days. If you want a conversation to survive for more than 30 days, make it a basic conversation instead. The code below creates a temporary conversation with a custom TTL:

<MultiLang>

```cs
LCIMTemporaryConversation temporaryConversation = await tom.CreateTemporaryConversation(new string[] { "Jerry", "William" },
    ttl: 3600);
```

```java
LCIMClient client = LCIMClient.getInstance("Tom");
client.open(new LCIMClientCallback() {
    @Override
    public void done(LCIMClient avimClient, LCIMException e) {
    if (null == e) {
        String[] members = {"Jerry", "William"};
        avimClient.createTemporaryConversation(Arrays.asList(members), 3600, new LCIMConversationCreatedCallback(){
        @Override
        public void done(LCIMConversation conversation, LCIMException e) {
            if (null == e) {
            LCIMTextMessage msg = new LCIMTextMessage();
            msg.setText("This is a temporary conversation. It will expire in 1 hour.");
            conversation.sendMessage(msg, new LCIMConversationCallback(){
                @Override
                public void done(LCIMException e) {
                }
            });
            }
        }
        });
    }
    }
});
```

```objc
LCIMConversationCreationOption *option = [LCIMConversationCreationOption new];
option.timeToLive = 3600;
[self createTemporaryConversationWithClientIds:@[@"Jerry", @"William"] option:option callback:^(LCIMTemporaryConversation * _Nullable temporaryConversation, NSError * _Nullable error) {
    if (temporaryConversation) {
        // success
    }
}];
```

```js
realtime
  .createIMClient("Tom")
  .then(function (tom) {
    return tom.createTemporaryConversation({
      members: ["Jerry", "William"],
      ttl: 3600,
    });
  })
  .then(function (conversation) {
    return conversation.send(
      new AV.TextMessage(
        "This is a temporary conversation. It will expire in 1 hour."
      )
    );
  })
  .catch(console.error);
```

```swift
do {
    try client.createTemporaryConversation(clientIDs: ["Jerry", "William"], timeToLive: 3600) { (result) in
        switch result {
        case .success(value: let tempConversation):
            print(tempConversation)
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```

```dart
TemporaryConversation temporaryConversation;
try {
  temporaryConversation = await jerry.createTemporaryConversation(
    members: {'Jerry', 'William'},
    timeToLive: 3600,
  );
} catch (e) {
  print(e);
}

try {
  TextMessage message = TextMessage();
  message.text = 'This is a temporary conversation. It will expire in 1 hour.';
  await temporaryConversation.send(message: message);
} catch (e) {
  print(e);
}
```

</MultiLang>

Besides this, a temporary conversation shares the same functionality as a basic conversation.

## Continue Reading

- [4. Hooks and System Conversations](/sdk/im/guide/systemconv/)
